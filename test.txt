--[[
ğŸ”¥ Ù†Ø¸Ø§Ù… Silent Aim Ø§Ù„Ø®Ø§Ø±Ù‚ Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ù‡Ø§ÙƒØ± Ø§Ù„Ù…ØªÙ‚Ø¯Ù… ğŸ”¥
BY Alya ROB ğŸŒ¸ - Ø­ØµØ±ÙŠØ§Ù‹ Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙÙŠ Ø¨ÙŠØ¦Ø§Øª Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„ØªØ·ÙˆÙŠØ±ÙŠØ©
]]

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— 
--â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—
--â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•
--â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—
--â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘
-- â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•

local AdvancedConfig = {
    Active = true,
    FOV = 360, -- 360 Ø¯Ø±Ø¬Ø© Ù„Ø¶Ù…Ø§Ù† Ø§Ù„ØªØºØ·ÙŠØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø©
    AutoTarget = true,
    TargetSelection = {
        Priority = "Closest", -- Closest | MostVisible | LeastHealth
        Parts = {"Head", "HumanoidRootPart", "Torso"},
        DynamicPartSelection = true
    },
    Prediction = {
        Advanced = true,
        VelocityScale = 0.3,
        AccelerationFactor = 0.1,
        PingCompensation = true
    },
    Stealth = {
        Humanizer = {
            NaturalMouseMovement = true,
            RandomOffset = {
                Enabled = true,
                MaxAngle = 2,
                MinAngle = 0.5
            },
            ReactionTime = {
                Min = 0.1,
                Max = 0.3
            }
        },
        AntiDetection = {
            PatternRandomization = true,
            FOVFluctuation = true,
            LegitAimCurves = true
        }
    },
    Visuals = {
        FOVIndicator = {
            Type = "Dynamic", -- Dynamic | Static | Gradient
            Color = Color3.fromRGB(255, 50, 50),
            Thickness = 2,
            Transparency = 0.7
        },
        TargetHighlight = {
            Enabled = true,
            Color = Color3.fromRGB(255, 0, 0),
            FillTransparency = 0.9
        }
    }
}

-- â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
--â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•
--   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   
--   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   
--   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   
--   â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•   â•šâ•â•   

local TargetSystem = {
    CurrentTarget = nil,
    TargetLock = false,
    TargetHistory = {},
    Performance = {
        ScanInterval = 0.1,
        LastScan = 0
    }
}

local PredictionEngine = {
    PositionCache = {},
    VelocityCache = {},
    AccelerationCache = {}
}

local Humanizer = {
    LastTargetChange = 0,
    RandomSeed = math.random(1, 10000),
    MovementPatterns = {
        "Linear",
        "SmoothCurve",
        "Step",
        "Randomized"
    }
}

-- â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— 
--â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—
--â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•
--â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—
--â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘
-- â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•  â•šâ•â•â•â•  â•šâ•â• â•šâ•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•

local function GetOptimalTargetPart(character)
    if not AdvancedConfig.TargetSelection.DynamicPartSelection then
        return character:FindFirstChild(AdvancedConfig.TargetSelection.Parts[1])
    end
    
    for _, partName in ipairs(AdvancedConfig.TargetSelection.Parts) do
        local part = character:FindFirstChild(partName)
        if part then
            local screenPos, visible = Camera:WorldToViewportPoint(part.Position)
            if visible then
                return part
            end
        end
    end
    return nil
end

local function CalculateAdvancedPrediction(targetPart)
    if not AdvancedConfig.Prediction.Advanced then
        return targetPart.Position
    end
    
    local now = tick()
    local character = targetPart.Parent
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    
    if not rootPart then return targetPart.Position end
    
    -- ØªØ­Ø¯ÙŠØ« Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª
    PredictionEngine.PositionCache[targetPart] = PredictionEngine.PositionCache[targetPart] or {}
    PredictionEngine.VelocityCache[targetPart] = PredictionEngine.VelocityCache[targetPart] or {}
    
    table.insert(PredictionEngine.PositionCache[targetPart], {
        Time = now,
        Position = targetPart.Position
    })
    
    -- Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø£Ø­Ø¯Ø« 5 Ù‚Ø±Ø§Ø¡Ø§Øª ÙÙ‚Ø·
    while #PredictionEngine.PositionCache[targetPart] > 5 do
        table.remove(PredictionEngine.PositionCache[targetPart], 1)
    end
    
    -- Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ù…ØªØ¬Ù‡Ø©
    if #PredictionEngine.PositionCache[targetPart] >= 2 then
        local lastEntry = PredictionEngine.PositionCache[targetPart][#PredictionEngine.PositionCache[targetPart]]
        local prevEntry = PredictionEngine.PositionCache[targetPart][#PredictionEngine.PositionCache[targetPart]-1]
        
        local velocity = (lastEntry.Position - prevEntry.Position) / (lastEntry.Time - prevEntry.Time)
        table.insert(PredictionEngine.VelocityCache[targetPart], velocity)
        
        while #PredictionEngine.VelocityCache[targetPart] > 3 do
            table.remove(PredictionEngine.VelocityCache[targetPart], 1)
        end
    end
    
    -- Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØ³Ø§Ø±Ø¹
    if #PredictionEngine.VelocityCache[targetPart] >= 2 then
        local lastVel = PredictionEngine.VelocityCache[targetPart][#PredictionEngine.VelocityCache[targetPart]]
        local prevVel = PredictionEngine.VelocityCache[targetPart][#PredictionEngine.VelocityCache[targetPart]-1]
        
        local acceleration = (lastVel - prevVel) / (now - PredictionEngine.PositionCache[targetPart][#PredictionEngine.PositionCache[targetPart]-1].Time)
        PredictionEngine.AccelerationCache[targetPart] = acceleration * AdvancedConfig.Prediction.AccelerationFactor
    end
    
    -- Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹
    local predictedPosition = targetPart.Position
    local averageVelocity = Vector3.new(0, 0, 0)
    
    if #PredictionEngine.VelocityCache[targetPart] > 0 then
        for _, vel in ipairs(PredictionEngine.VelocityCache[targetPart]) do
            averageVelocity += vel
        end
        averageVelocity /= #PredictionEngine.VelocityCache[targetPart]
    end
    
    local distance = (targetPart.Position - Camera.CFrame.Position).Magnitude
    local timeToHit = distance / 2000 -- Ø§ÙØªØ±Ø§Ø¶ Ø³Ø±Ø¹Ø© Ø§Ù„Ø±ØµØ§Øµ
    
    predictedPosition = predictedPosition + (averageVelocity * timeToHit * AdvancedConfig.Prediction.VelocityScale)
    
    if PredictionEngine.AccelerationCache[targetPart] then
        predictedPosition = predictedPosition + (PredictionEngine.AccelerationCache[targetPart] * (timeToHit^2))
    end
    
    -- ØªØ¹ÙˆÙŠØ¶ Ø§Ù„Ø¨ÙŠÙ†Ø¬ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙØ¹Ù„Ø§Ù‹
    if AdvancedConfig.Prediction.PingCompensation then
        local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
        predictedPosition = predictedPosition + (averageVelocity * (ping/1000))
    end
    
    return predictedPosition
end

local function HumanizeAim(direction, targetPos)
    if not AdvancedConfig.Stealth.Humanizer.Enabled then
        return direction
    end
    
    -- ØªØ·Ø¨ÙŠÙ‚ ÙˆÙ‚Øª Ø±Ø¯ ÙØ¹Ù„ Ø¨Ø´Ø±ÙŠ
    if tick() - Humanizer.LastTargetChange < math.random(
        AdvancedConfig.Stealth.Humanizer.ReactionTime.Min,
        AdvancedConfig.Stealth.Humanizer.ReactionTime.Max
    ) then
        return direction
    end
    
    -- Ø¥Ø¶Ø§ÙØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ø·Ø¨ÙŠØ¹ÙŠØ©
    if AdvancedConfig.Stealth.Humanizer.RandomOffset.Enabled then
        local offsetAngle = math.rad(math.random(
            AdvancedConfig.Stealth.Humanizer.RandomOffset.MinAngle * 100,
            AdvancedConfig.Stealth.Humanizer.RandomOffset.MaxAngle * 100
        ) / 100)
        
        local randomVec = Vector3.new(
            math.random() * 2 - 1,
            math.random() * 2 - 1,
            math.random() * 2 - 1
        ).Unit
        
        direction = direction:Lerp((direction + (randomVec * offsetAngle)).Unit, 0.5)
    end
    
    -- Ù†Ù…Ø· Ø­Ø±ÙƒØ© Ø¨Ø´Ø±ÙŠ
    if AdvancedConfig.Stealth.Humanizer.NaturalMouseMovement then
        local pattern = Humanizer.MovementPatterns[
            math.random(1, #Humanizer.MovementPatterns)
        ]
        
        if pattern == "SmoothCurve" then
            direction = direction:Lerp((targetPos - Camera.CFrame.Position).Unit, 0.7)
        elseif pattern == "Step" then
            direction = (direction * 0.8 + (targetPos - Camera.CFrame.Position).Unit * 0.2).Unit
        elseif pattern == "Randomized" then
            direction = (direction * 0.6 + (targetPos - Camera.CFrame.Position).Unit * 0.4).Unit
        end
    end
    
    return direction
end

-- Ù†Ø¸Ø§Ù… Ø§Ù„ØªØµÙˆÙŠØ¨ Ø§Ù„Ø®Ø§Ø±Ù‚
local function SuperAim(origin, direction)
    if not AdvancedConfig.Active or not TargetSystem.CurrentTarget then
        return direction
    end
    
    local targetPart = TargetSystem.CurrentTarget.Part
    if not targetPart then return direction end
    
    local predictedPosition = CalculateAdvancedPrediction(targetPart)
    local aimDirection = (predictedPosition - origin).Unit
    
    -- ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ¨Ø±ÙŠØ¯ Ø§Ù„Ø¨Ø´Ø±ÙŠ
    aimDirection = HumanizeAim(direction, predictedPosition)
    
    return aimDirection
end

-- Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø³Ø­ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
RunService.Heartbeat:Connect(function(deltaTime)
    if not AdvancedConfig.Active then return end
    
    TargetSystem.Performance.LastScan += deltaTime
    if TargetSystem.Performance.LastScan < TargetSystem.Performance.ScanInterval then
        return
    end
    TargetSystem.Performance.LastScan = 0
    
    -- Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†
    local potentialTargets = {}
    local cameraPos = Camera.CFrame.Position
    local cameraVector = Camera.CFrame.LookVector
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if AdvancedConfig.TeamCheck and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        
        local targetPart = GetOptimalTargetPart(character)
        if not targetPart then continue end
        
        -- Ø­Ø³Ø§Ø¨ Ø§Ù„Ø²Ø§ÙˆÙŠØ©
        local direction = (targetPart.Position - cameraPos).Unit
        local angle = math.deg(math.acos(cameraVector:Dot(direction)))
        
        if angle <= AdvancedConfig.FOV then
            -- Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±Ø¤ÙŠØ© Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙØ¹Ù„Ø§Ù‹
            if AdvancedConfig.VisibilityCheck then
                local raycastParams = RaycastParams.new()
                raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, character}
                raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                local raycastResult = workspace:Raycast(cameraPos, direction * 2000, raycastParams)
                
                if raycastResult and not raycastResult.Instance:IsDescendantOf(character) then
                    continue -- ÙŠÙˆØ¬Ø¯ Ø¹Ø§Ø¦Ù‚
                end
            end
            
            table.insert(potentialTargets, {
                Player = player,
                Part = targetPart,
                Angle = angle,
                Distance = (targetPart.Position - cameraPos).Magnitude,
                Health = humanoid.Health
            })
        end
    end
    
    -- Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù‡Ø¯Ù Ø­Ø³Ø¨ Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©
    if #potentialTargets > 0 then
        table.sort(potentialTargets, function(a, b)
            if AdvancedConfig.TargetSelection.Priority == "Closest" then
                return a.Distance < b.Distance
            elseif AdvancedConfig.TargetSelection.Priority == "MostVisible" then
                return a.Angle < b.Angle
            elseif AdvancedConfig.TargetSelection.Priority == "LeastHealth" then
                return a.Health < b.Health
            end
            return a.Angle < b.Angle
        end)
        
        if TargetSystem.CurrentTarget ~= potentialTargets[1] then
            Humanizer.LastTargetChange = tick()
        end
        
        TargetSystem.CurrentTarget = potentialTargets[1]
    else
        TargetSystem.CurrentTarget = nil
    end
end)

-- Ù†Ø¸Ø§Ù… Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø±Ø¦ÙŠØ©
local function SetupVisuals()
    local FOVCircle = Drawing.new("Circle")
    FOVCircle.Visible = AdvancedConfig.Visuals.FOVIndicator.Enabled
    FOVCircle.Color = AdvancedConfig.Visuals.FOVIndicator.Color
    FOVCircle.Thickness = AdvancedConfig.Visuals.FOVIndicator.Thickness
    FOVCircle.Transparency = AdvancedConfig.Visuals.FOVIndicator.Transparency
    FOVCircle.NumSides = 64
    FOVCircle.Filled = false
    
    RunService.RenderStepped:Connect(function()
        FOVCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
        FOVCircle.Radius = AdvancedConfig.FOV * 3
        FOVCircle.Visible = AdvancedConfig.Active and AdvancedConfig.Visuals.FOVIndicator.Enabled
        
        -- ØªØ­Ø¯ÙŠØ« Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ Ù„Ù†ÙˆØ¹ Ø§Ù„Ù…Ø¤Ø´Ø±
        if AdvancedConfig.Visuals.FOVIndicator.Type == "Gradient" then
            local hue = (tick() % 5)/5
            FOVCircle.Color = Color3.fromHSV(hue, 1, 1)
        elseif AdvancedConfig.Visuals.FOVIndicator.Type == "Dynamic" then
            FOVCircle.Thickness = 1 + math.sin(tick() * 3) * 1.5
        end
    end)
end

SetupVisuals()

-- Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ­ÙƒÙ…
local function ToggleSilentAim(state)
    AdvancedConfig.Active = state
    if state then
        print("ğŸ”¥ Ù†Ø¸Ø§Ù… Silent Aim Ø§Ù„Ø®Ø§Ø±Ù‚ Ù…ÙØ¹Ù„!")
    else
        print("âŒ Ø§Ù„Ù†Ø¸Ø§Ù… Ù…Ø¹Ø·Ù„")
    end
end

-- ØªØµØ¯ÙŠØ± Ø§Ù„ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
return {
    SuperAim = SuperAim,
    Toggle = ToggleSilentAim,
    GetConfig = function() return AdvancedConfig end,
    GetCurrentTarget = function() return TargetSystem.CurrentTarget end
}
